# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_critic.ipynb.

# %% auto 0
__all__ = ['tavily_search', 'interpreter', 'TOOL_MAP', 'LLM', 'MAX_NUM_ITERATIONS', 'builder', 'critic', 'CriticState',
           'assistant', 'tools', 'tool_call']

# %% ../nbs/00_critic.ipynb 3
from IPython.display import Image, display
from langgraph.graph import StateGraph, END, START
from langchain_openai import ChatOpenAI
from langchain_core.messages import (
    HumanMessage,
    SystemMessage,
    ToolMessage,
    BaseMessage,
)
from langchain_community.tools import TavilySearchResults
from langchain_community.tools.riza.command import ExecPython
from pydantic import BaseModel, Field
from typing import Literal
import textwrap
import os

# %% ../nbs/00_critic.ipynb 5
tavily_search = TavilySearchResults(
    max_results=5,
    search_depth="advanced",
    include_answer=True,
    include_raw_content=True,
    include_images=True,
)
interpreter = ExecPython()

# collect tools
TOOL_MAP = {tool.name: tool for tool in [tavily_search, interpreter]}

# %% ../nbs/00_critic.ipynb 7
LLM = ChatOpenAI(
    model_name="gpt-4o-mini",
    openai_api_key=os.getenv("OPENAI_API_KEY"),
    temperature=0.0,
).bind_tools(list(TOOL_MAP.values()), strict=True, tool_choice="auto")

# %% ../nbs/00_critic.ipynb 9
class CriticState(BaseModel):
    """
    Represents the state of the Critic during execution, as defined in Algorithm 1 of the referenced paper.
    """

    p: SystemMessage
    x: HumanMessage
    y: list[BaseMessage] = Field(description="Chat history of the agent", default=[])
    c: list[ToolMessage] = Field(description="Latest Tool Messages", default=[])
    num_iterations: int = Field(
        description="Maximum number a tool can be called", default=0
    )

# %% ../nbs/00_critic.ipynb 13
def assistant(state: CriticState) -> CriticState:
    """
    Processes the critic state by appending new results to the state history.

    Parameters
    ----------
    state
        Current state of the Critic, containing past results and parameters.

    Returns
    -------
    state
        Updated state including new results from invoking the LLM.
    """
    if state.c:
        state.y.extend(state.c)
    return {"y": [*state.y, LLM.invoke([state.p, state.x, *state.y])]}


def tools(state: CriticState) -> CriticState:
    """
    Executes sequential tool calls based on the provided critic state.

    Parameters
    ----------
    state
        Current state of the Critic, containing tool calls and iteration data.

    Returns
    -------
    state
        Updated state with results from invoked tool calls and incremented iteration count.
    """
    return {
        "c": [TOOL_MAP[tc["name"]].invoke(tc) for tc in state.y[-1].tool_calls],
        "num_iterations": state.num_iterations + 1,
    }

# %% ../nbs/00_critic.ipynb 15
MAX_NUM_ITERATIONS = 5


def tool_call(state: CriticState) -> Literal["tools", END]:
    """
    Determines the next action for the Critic based on the current state.

    Parameters
    ----------
    state
        The current state of the Critic, including the history of tool calls and the iteration count.

    Returns
    -------
    node
        Returns 'tools' if additional tool calls are required and the maximum number of iterations
        has not been reached. Returns END otherwise.
    """
    return (
        END
        if (not state.y[-1].tool_calls) or state.num_iterations >= MAX_NUM_ITERATIONS
        else "tools"
    )

# %% ../nbs/00_critic.ipynb 17
# Graph
builder = StateGraph(CriticState)

# Define nodes: these do the work
builder.add_node("assistant", assistant)
builder.add_node("tools", tools)

# Define edges: these determine how the control flow moves
builder.add_edge(START, "assistant")
builder.add_conditional_edges("assistant", tool_call)
builder.add_edge("tools", "assistant")
critic = builder.compile()
