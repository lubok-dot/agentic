# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_critic.ipynb.

# %% auto 0
__all__ = ['tavily_search', 'interpreter', 'TOOL_MAP', 'LLM', 'p', 'MAX_NUM_ITERATIONS', 'builder', 'critic', 'CriticState',
           'assistant', 'tools', 'tool_call']

# %% ../nbs/00_critic.ipynb 3
from IPython.display import Image, display
from langgraph.graph import StateGraph, END, START
from langchain_openai import ChatOpenAI
from langchain_core.messages import (
    HumanMessage,
    SystemMessage,
    ToolMessage,
    BaseMessage,
)
from langchain_community.tools import TavilySearchResults
from langchain_community.tools.riza.command import ExecPython
from pydantic import BaseModel, Field
from typing import Literal
import textwrap
import os

# %% ../nbs/00_critic.ipynb 5
tavily_search = TavilySearchResults(
    max_results=5,
    search_depth="advanced",
    include_answer=True,
    include_raw_content=True,
    include_images=True,
)
interpreter = ExecPython()

# collect tools
TOOL_MAP = {tool.name: tool for tool in [tavily_search, interpreter]}

# %% ../nbs/00_critic.ipynb 7
LLM = ChatOpenAI(
    model_name="gpt-4o-mini",
    openai_api_key=os.getenv("OPENAI_API_KEY"),
    temperature=0.0,
).bind_tools(list(TOOL_MAP.values()), strict=True, tool_choice="auto")

# %% ../nbs/00_critic.ipynb 9
class CriticState(BaseModel):
    """
    Represents the state of the Critic during execution, as defined in Algorithm 1 of the referenced paper.
    """

    p: SystemMessage
    x: HumanMessage
    y: list[BaseMessage] = Field(
        description="Chat history of the agent", default=[])
    c: list[ToolMessage] = Field(
        description="Latest Tool Messages", default=[])
    num_iterations: int = Field(
        description="Maximum number a tool can be called", default=0
    )

# %% ../nbs/00_critic.ipynb 11
p = SystemMessage(
    textwrap.dedent(
        """
    Perform the tasks of question answering and mathematical problem solving by interacting with the Internet via TavilySearch and executing Python code respectively. Use TavilySearch for context retrieval in free-form question answering and Python code for mathematical problem synthesis. Align the approaches with the AmbigNQ and GSMK8 datasets.

    # Task Descriptions

    1. **Question Answering:**
       - Retrieve context using TavilySearch to search the Internet and to provide accurate answers to factual questions.
       - Focus on truthfulness and plausibility checks during verification.

    2. **Mathematical Problem Solving:**
       - Generate Python code execution to solve mathematical problems effectively.
       - Run the Python Code by Calling the RIZA Code Interpreter. Ensure that your final result is printed. That is, the generated code should always end with a print statement ```print(...)``` which prints the final result.
       - Ensure the correctness of calculations and consider plausible reasoning before final conclusions.

    # Steps

    1. **Input Processing**: Given a query, determine whether it is a factual question or a mathematical problem.
    2. **Context Retrieval/Execution**:
       - For factual questions, utilize the Internet to extract relevant information.
       - For mathematical problems, generate Python code and execute it to derive the answer.
    3. **Verification and Correction**:
       - Verify factual information retrieved from the Internet using TavilySearch to ensure it is up-to-date and correct.
       - Verify mathematical solutions by evaluating the Python execution for accuracy and logical consistency.
    4. **Generate Answer**: Conclude with a verified answer, ensuring that any corrections have been applied based on the verification steps.

    # Output Format

    - **Response Type**: Structured text with a clear final answer.
    - **Formatting**: For factual answers, provide the main conclusion last. For mathematical solutions, display the final numeric answer only.

    # Examples

    1. **Question Answering Example**:

       - **Input**: Which performance act has a higher instrument to person ratio, Badly Drawn Boy or Wolf Alice?
       
       - **Process**:

         Proposed Answer: 
            Let’s think step by step. Badly Drawn Boy is a solo act with one person and one instrument. Wolf Alice is a band with four
            people and multiple instruments. So Wolf Alice has a higher instrument to person ratio. So the answer is: Wolf Alice. What’s 
            the problem with the above answer?

         1. Plausibility:
            The question asks for a name, and the answer "Wolf Alice" is a name. So it’s plausible.
         2. Truthfulness:
            Let’s search the question in the Internet:
            > Search Query: Which performance act has a higher instrument to person ratio, Badly Drawn Boy or Wolf Alice?
            > Evidence: [nlpproject2023/Sentences - Datasets at Hugging Face] ...Wolf Alice are a four-piece alternative rock band from... The evidence suggests that Wolf Alice is a four-piece alternative rock band.
            Let’s search the proposed answer in the Internet:
            > Search Query: Badly Drawn Boy is a solo instrument.
            > Evidence: act with one person and one
            [Badly Drawn Boy - TavilySearch] Singer-songwriter - Guitar, vocals, bass, drums, percussion, banjo, piano, keyboards, harmonica - 1995-present... Missing: act | Must include: act The evidence suggests that 
            Badly Drawn Boy is a singer-songwriter with multiple instruments. We need to find out the instrument to person ratio of both acts.
            > Search Query: What is the instrument to Boy?
            > Evidence: [Badly Drawn Boy - TavilySearch] person ratio of Badly Drawn ... consisted of Matt Wardle
            (keyboards/vocals), Robin File (guitar), Sean McCann (bass guitar) latterly replaced by the ex-Smiths bass guitarist Andy Rourke, Dave Verner (drums).
            The evidence suggests that the instrument to person ratio of Badly Drawn Boy is 4:1.
            > Search Query: > Evidence: What is the instrument to person ratio of Wolf Alice?
            [Wolf Alice - TavilySearch] ...Formed in 2010 as an acoustic duo comprising singer Ellie Rowsell and guitarist Joff Oddie, Wolf Alice have also featured bassist Theo Ellis and drummer Joel Amey since 2012...
            The evidence suggests that the instrument to person ratio of Wolf Alice is 1:1.
            The proposed answer is incorrect since Badly Drawn Boy has a higher instrument to person ratio than Wolf Alice.

         Question: Which performance act has a higher instrument to person ratio, Badly Drawn Boy or Wolf Alice?
         Here’s the most possible answer: Let’s think step by step. Badly Drawn Boy is a solo act with four people and multiple instruments. Wolf Alice is a band with four people and one instrument. So Badly Drawn
         Boy has a higher instrument to person ratio. So the answer is: Badly Drawn Boy.

       - **Output**: Badly Drawn Boy

    2. **Mathematical Problem Solving Example**:

       - **Input**: Generally, a 5-year-old avocado tree produces 50 fruits, a 6-year-old one produces 3 times the initial amount of fruits, a 7-year-
                  old one produces 7 times the initial amount, and an 8-year-old produces 200 fruits less than a 10-year-old one. During the ninth
                  year, the avocado tree doesn’t produce any fruit, and then a 10-year-old tree produces 20 times the initial amount of fruits. How many
                  total fruits can an avocado tree produce during its 10 years of life?
       
       - **Process**:
         ```python
         initial_fruits = 50
         num_of_fruits_in_6th_year = 3 * initial_fruits
         num_of_fruits_in_7th_year = 7 * initial_fruits
         num_of_fruits_in_8th_year = num_of_fruits_in_10th_year - 200
         num_of_fruits_in_10th_year = 20 * initial_fruits
         answer = initial_fruits + num_of_fruits_in_6th_year + num_of_fruits_in_7th_year + num_of_fruits_in_8th_year + num_of_fruits_in_10th_year
         print(answer)  # Ensure the final result is explicitly printed
         ```

         Execution: NameError("name ’num_of_fruits_in_10th_year’ is not defined")
         Output: answer = None

         What’s the problem with the above code?
         1. The above code causes the "NameError" because it use the variable ‘num_of_fruits_in_10th_year‘ before it is defined.
         2. The order of the calculation is not correct, ‘num_of_fruits_in_8th_year‘ should be calculated after ‘num_of_fruits_in_10th_year‘.
         Let’s analysis the problem, we can calculate the number of fruits for each year based on the description in the question.
         Here’s a better solution:
         ‘‘‘python
         initial_fruits = 50
         num_of_fruits_in_6th_year = 3 * initial_fruits
         num_of_fruits_in_7th_year = 7 * initial_fruits
         num_of_fruits_in_9th_year = 0
         num_of_fruits_in_10th_year = 20 * initial_fruits
         num_of_fruits_in_8th_year = num_of_fruits_in_10th_year - 200
         total_fruits = (
         initial_fruits
         + num_of_fruits_in_6th_year
         + num_of_fruits_in_7th_year
         + num_of_fruits_in_8th_year
         + num_of_fruits_in_9th_year
         + num_of_fruits_in_10th_year
         )
         answer = total_fruits
         print(answer)  # Ensure the final result is explicitly printed
         ‘‘‘
         Execution: Output: Done
         answer = 2350.0

       - **Output**: 2350.0

    # Notes

    - For ambiguous questions, use multiple sources to triangulate the most accurate information.
    - For mathematical errors, iterate the correction until logical consistency is achieved.
    - Ensure that the final answer of your code is always explicitly printed using `print()`.
"""
    ).strip()
)

# %% ../nbs/00_critic.ipynb 13
def assistant(state: CriticState) -> CriticState:
    """
    Processes the critic state by appending new results to the state history.

    Parameters
    ----------
    state
        Current state of the Critic, containing past results and parameters.

    Returns
    -------
    state
        Updated state including new results from invoking the LLM.
    """
    if state.c:
        state.y.extend(state.c)
    return {"y": [*state.y, LLM.invoke([state.p, state.x, *state.y])]}


def tools(state: CriticState) -> CriticState:
    """
    Executes sequential tool calls based on the provided critic state.

    Parameters
    ----------
    state
        Current state of the Critic, containing tool calls and iteration data.

    Returns
    -------
    state
        Updated state with results from invoked tool calls and incremented iteration count.
    """
    return {
        "c": [TOOL_MAP[tc["name"]].invoke(tc) for tc in state.y[-1].tool_calls],
        "num_iterations": state.num_iterations + 1,
    }

# %% ../nbs/00_critic.ipynb 15
MAX_NUM_ITERATIONS = 5


def tool_call(state: CriticState) -> Literal["tools", END]:
    """
    Determines the next action for the Critic based on the current state.

    Parameters
    ----------
    state
        The current state of the Critic, including the history of tool calls and the iteration count.

    Returns
    -------
    node
        Returns 'tools' if additional tool calls are required and the maximum number of iterations
        has not been reached. Returns END otherwise.
    """
    return (
        END
        if (not state.y[-1].tool_calls) or state.num_iterations >= MAX_NUM_ITERATIONS
        else "tools"
    )

# %% ../nbs/00_critic.ipynb 17
# Graph
builder = StateGraph(CriticState)

# Define nodes: these do the work
builder.add_node("assistant", assistant)
builder.add_node("tools", tools)

# Define edges: these determine how the control flow moves
builder.add_edge(START, "assistant")
builder.add_conditional_edges("assistant", tool_call)
builder.add_edge("tools", "assistant")
critic = builder.compile()
